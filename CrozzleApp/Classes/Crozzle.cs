using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;

namespace CrozzleApp.Classes
{
    class Crozzle
    {
        // Determines if the file is valid
        private bool valid = true;

        // Create a Configuration object
        Configuration configuration;

        // Create a Words object
        Words wordList;

        // Create a Grid object
        Grid grid;

        /* 
         * List of KeyValuePair organizes key value 
         * pairs to be used in ValidadeFile
         * and ValidadeCrozzle
        */
        private List<KeyValuePair<string, string>> lines = new List<KeyValuePair<string, string>>();

        /* 
         * Crozzle Size.
         * The number of rows and columns.
         * It must be generated by Grid.
        */
        private int rows;

        private int columns;

        private string root;

        private string filePath;

        private List<Tuple<int, string, int>> dataRowList = new List<Tuple<int, string, int>>();
        private List<Tuple<int, string, int>> dataColList = new List<Tuple<int, string, int>>();

        public int Rows { get => rows; private set => rows = value; }
        public int Columns { get => columns; private set => columns = value; }
        public bool Valid
        {
            get => valid;
            private set => valid = value;
        }

        //OpenFileDialog passes file as a parameter in Crozzle class
        public Crozzle(string file)
        {
            root = Path.GetDirectoryName(file);
            ReadFile(file);
            ValidateFile();
            ValidadeCrozzle();
        }

        #region CROZZLE METHODS
        //TODO ReadFile here, use system IO
        private void ReadFile(string file)
        {
            try
            {
                using (StreamReader sr = new StreamReader(file))
                {
                    string line;

                    while ((line = sr.ReadLine()) != null)
                    {
                        line = line.Replace("\"", "");

                        line = line.Trim();

                        int index = line.IndexOf(@"//");

                        if (index >= 0)
                        {
                            line = line.Remove(index);
                            line = line.Trim();
                        }
                        if (string.IsNullOrEmpty(line) || line.StartsWith(@"//"))
                        {
                            continue;
                        }
                        
                        string[] keyValuePair = line.Split(new char[] { '=' });

                        if (keyValuePair.Length == 2)
                        {
                            lines.Add(new KeyValuePair<string, string>(keyValuePair[0], keyValuePair[1]));
                        }
                        else
                        {
                            valid = false;
                            Exception ex = new IndexOutOfRangeException();
                            Log.logs.Add(keyValuePair[0] + " - " + ex.Message);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                valid = false;
                Log.logs.Add(ex.Message);
            }
        }

        //TODO Validate itens
        private void ValidateFile()
        {
            foreach (KeyValuePair<string, string> pair in lines)
            {
                switch(pair.Key)
                {
                    case "CONFIGURATION_FILE":
                        filePath = root + (pair.Value).Remove(0, 1);
                        configuration = new Configuration(filePath);
                        break;
                    case "WORDLIST_FILE":
                        filePath = root + pair.Value.Remove(0, 1);
                        wordList = new Words(filePath);
                        break;
                    case "ROWS":
                        Rows = CheckNumber(pair.Key, pair.Value);
                        break;
                    case "COLUMNS":
                        Columns = CheckNumber(pair.Key, pair.Value);
                        break;
                    case "ROW":
                        CheckWordData(pair.Key, pair.Value);
                        break;
                    case "COLUMN":
                        CheckWordData(pair.Key, pair.Value);
                        break;
                }
            }
        }

        private void ValidadeCrozzle()
        {
            // All indexes must return true.
            bool[] validation = {
                valid,
                configuration.Valid,
                wordList.Valid,
                CheckHorVertNumberWords(),
                CheckNumberOfSameWord(),
                CheckCrozzleSize(),
            };

            foreach (bool valid in validation)
            {
                if (valid == false)
                {
                    // TODO Invalid data somewhere.
                }
                else
                {
                    grid = new Grid(rows, columns);
                }
            }

        }

        private void CheckWordData(string key, string value)
        {
            int firstNumber;
            int secondNumber;
            string name;

            string[] values = value.Split(new char[] { ',' });

            if (values.Length == 3)
            {
                name = CheckName(key, values[1]);
                firstNumber = CheckNumber(key, values[0]);
                secondNumber = CheckNumber(key, values[2]);

                if (firstNumber > 0 && secondNumber > 0 && name != null)
                {
                    if (key == "ROW")
                    {
                        dataRowList.Add(new Tuple<int, string, int>(firstNumber, name, secondNumber));
                    }
                    else
                    {
                        dataColList.Add(new Tuple<int, string, int>(firstNumber, name, secondNumber));
                    }
                }
                else
                {
                    valid = false;
                }
                
            }
        }

        private string CheckName(string key, string name)
        {
            Match match = Regex.Match(name, @"(^[a-zA-Z]\w*$)");
            if (!match.Success)
            {
                Log.logs.Add(key + " - " + "Invalid name: " + name);
                return null;
            }
            else
            {
                return name;
            }
        }

        private int CheckNumber(string key, string value)
        {
            int number = 0;
            try
            {
                number = int.Parse(value);
                if (number < 1)
                {
                    valid = false;
                    Log.logs.Add(key + " - Has value smaller than 1: " + number);
                }
            }
            catch (Exception ex)
            {
                valid = false;
                Log.logs.Add(key + " - " + ex.Message);
            }
            return number;
        }

        /* 
         * @CheckNumberOfSameWord returns false by default
         * it MUST reach the last if statement to return true.
         */
        private bool CheckNumberOfSameWord()
        {
            // Temporary List to join both dataRowList and dataColList
            List<Tuple<int, string, int>> temp = dataRowList;

            // Add list from dataColList into temp list
            temp.AddRange(dataColList);

            /*
             * Create a group list of duplicated words
             * from temp list
             */
            var sameWord = temp.GroupBy(x => x.Item2)
                              .Where(g => g.Count() > 1)
                              .ToList();

            if (sameWord.Count > 0)
            {
                if (sameWord.Count >= configuration.MinNumberSameWord && sameWord.Count <= configuration.MaxNumberSameWord)
                {
                    return true;
                    // TODO Check if all duplicated values have the same row and column number
                    //foreach (var data in sameWord)
                    //{

                    //}
                }
            }

            return false;

            //var test = sameWordRow[0].ToList().Count;
        }

        /* 
         * @CheckHorVertNumberWords returns false by default
         * it MUST reach the last if statement to return true.
         * It checks both minimum and maximum number of words
         * in vertical and horizontal position.
         */
        private bool CheckHorVertNumberWords()
        {
            if (dataRowList.Count >= configuration.MinHorzWords && dataRowList.Count <= configuration.MaxHorzWords)
            {
                if (configuration.MinVertWords > dataColList.Count || configuration.MaxVertWords < dataColList.Count)
                {
                    return true;
                }  
            }

            return false;
        }

        /* 
         * @CheckCrozzleSize returns true by default
         * it MUST pass all if statements to reach true.
         */
        private bool CheckCrozzleSize()
        {
            /* 
            * Checks if number of rows and columns are equal or bigger
            * than minimum number of rows and columns from configuration 
            * and if number of rows and columns are equal or smaller
            * than maximum number of rows and columns also from configuration
            */
            if ((rows >= configuration.MinNumberRows && rows <= configuration.MaxNumberRows) && 
                (columns >= configuration.MinNumberCol && columns <= configuration.MaxNumberCol))
            {
                /* 
                 * Checks if number of rows and columns are equal or bigger
                 * than number of words in dataRowList and dataColList.
                */
                if (rows >= dataRowList.Count && columns >= dataColList.Count)
                {
                    // Loop dataRowList first, then dataColList.
                    foreach (var data in dataRowList)
                    {
                        /*
                         * Checks if start row number is bigger than number of rows available
                         * or combinations of start column number + word length is bigger than
                         * than number of columns available
                        */
                        if (data.Item1 > rows || (data.Item2.Length - 1 + data.Item3) > columns)
                        {
                            // TODO generate error
                            return false;
                        }
                    }
                                        
                    foreach (var data in dataColList)
                    {
                        /*
                        * Checks if start column number is bigger than number of columns available
                        * or combinations of start row number + word length is bigger than
                        * than number of rows available
                        */
                        if (data.Item1 > columns || (data.Item2.Length - 1 + data.Item3) > rows)
                        {
                            return false;
                            // TODO generate error
                        }
                    }
                }
                else
                {
                    return false;
                    // TODO Implement else
                }
            }
            else
            {
                return false;
                // TODO Implement else
            }

            return true;
        }

        #endregion
    }
}
